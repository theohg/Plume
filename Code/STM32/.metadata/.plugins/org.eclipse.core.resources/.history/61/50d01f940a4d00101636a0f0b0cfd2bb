/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "adc.h"
#include "dma.h"
#include "i2c.h"
#include "ipcc.h"
#include "memorymap.h"
#include "rtc.h"
#include "spi.h"
#include "tim.h"
#include "usart.h"
#include "gpio.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include <stdbool.h>                // For boolean type
#include <stdio.h>                  // For printf
#include "WS2812_SPI.h"             // For WS2812 LED control
#include "drv8214.h"                // For DRV8214 driver control
#include "drv8214_platform_i2c.h"   // For I2C functions
#include "TCA9548.h"                // For I2C MUX control  
#include "bmi270.h"                 // For BMI270 IMU
#include "bmi2_user_interface.h"    // For BMI270 user interface
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
typedef enum {
  WAKEUP_SOURCE_UNKNOWN,
  WAKEUP_SOURCE_IMU,
  WAKEUP_SOURCE_BUTTON, // If you add button wakeups
  WAKEUP_SOURCE_RTC     // If you add RTC wakeups
} WakeupSource_t;
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
// ADC settings
#define VREF_MCU                    3.3f     // ADC Reference Voltage (e.g., 3.3V)
#define ADC_RESOLUTION              4095.0f  // For 12-bit ADC (2^12 - 1)
#define R502_VALUE                  3000.0f  // 3k Ohm
#define R503_VALUE                  10000.0f // 10k Ohm
#define BATTERY_SENSE_DIVIDER_RATIO ((R502_VALUE + R503_VALUE) / R503_VALUE)

// Driver and motor configuration
#define NUM_DRIVERS 2 // Number of DRV8214 drivers in the system
#define IPROPI_RESISTOR 680 // Value in Ohms of the resistor connected to IPROPI pin
#define NUM_RIPPLES 6 // Number of current ripples per output shaft revolution (= nb of ripples per motor revolution x reduction ratio)
#define MOTOR_INTERNAL_RESISTANCE 20 // Internal resistance of the motor in Ohms
#define MOTOR_REDUCTION_RATIO 26 // Reduction ratio of the motor
#define MAX_MOTOR_RPM 1154 // Maximum speed of the motor in RPM 1154

// IMU
#define INACTIVITY_TIMEOUT_MS 1000 // 30 seconds

// prinf destination
//#define USE_UART
#define USE_SWD
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */
// Battery ADC
extern TIM_HandleTypeDef htim2;
extern ADC_HandleTypeDef hadc1;
volatile uint8_t g_measure_battery_flag = 0;
float g_battery_voltage = 0.0f;

// Button press detection
volatile bool wakeup_event = false;
volatile uint8_t button_ID = 0;

// Module configuration
uint16_t full_range_ripples = 29100;
float full_range_mm = 4.0;
float half_range_ripples = full_range_ripples / 2;
float nb_ripples_per_mm = full_range_ripples / full_range_mm;

// MUX
i2c_mux_t i2c_multiplexer;
uint8_t i2c_channel_to_use =1;

//UART
extern UART_HandleTypeDef huart1;

// IMU
extern I2C_HandleTypeDef hi2c3;
struct bmi2_dev bmi270_sensor;  // BMI270 device structure
extern TIM_HandleTypeDef htim16;
volatile bool inactivity_timer_elapsed_flag = false;
volatile bool imu_wakeup_pending = false; // Flag set by EXTI for IMU
volatile bool woke_up_from_stop_mode = false;
WakeupSource_t g_wakeup_source = WAKEUP_SOURCE_UNKNOWN;

// Global variables
static uint16_t speed = MAX_MOTOR_RPM * 0.7;
static uint16_t speed_low = MAX_MOTOR_RPM*0.5;
static float voltage = 3.0;
static float current = 1;
static int speed_step = 5; // speed_step ranges from 1 (lowest) to 5 (full speed)
static float nb_of_steps = 5;
static uint8_t faults = 0;
uint16_t ripple_target = 27000;    // Number of ripples to move when in ripple mode
static const bool stops_after_ripples = true;   // If true, the motor will stop when ripple_target is reached
static const bool stops_at_stall = true;        // If true, the motor will stop when a stall is detected
uint8_t i2c_channel = 1;           // I2C channel to select
bool back_and_forth = 0;           // If true, the motor will move back and forth
bool use_ripple_mode = 0;          // Set to true to use ripple-based motion
bool stopped = true;
bool direction_changed = false;
const unsigned long led_300 = 300; // LED ON in milliseconds for short pules
unsigned long redStartTime = 0;
bool isRedActive = false;
uint32_t savedColor = 0;  // To store the previous LED color
bool stalled = false;
bool channel_mode = false;
bool speed_mode = false;
bool direction = false;
float target_position = 0.0;
float module_position = 0.0;
bool last_direction;
bool is_moving = false;
uint16_t last_ripple_count = 0;
uint16_t current_ripple_count = 0;

// Create an array of DRV8214 objects
DRV8214 drivers[NUM_DRIVERS] = {
 DRV8214(DRV8214_I2C_ADDR_11, 8, IPROPI_RESISTOR, NUM_RIPPLES, MOTOR_INTERNAL_RESISTANCE, MOTOR_REDUCTION_RATIO, MAX_MOTOR_RPM),
 DRV8214(DRV8214_I2C_ADDR_11, 17, IPROPI_RESISTOR, NUM_RIPPLES, MOTOR_INTERNAL_RESISTANCE, MOTOR_REDUCTION_RATIO, MAX_MOTOR_RPM)
};

// Create an array of configuration structs
DRV8214_Config driver_configs[NUM_DRIVERS];
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
void PeriphCommonClock_Config(void);
/* USER CODE BEGIN PFP */
void I2C_Scan(I2C_HandleTypeDef *hi2c);
void printByteAsBinary(uint8_t value);      // Prints an 8-bit value as binary with leading zeros
void print2BytesAsBinary(uint16_t value);   // Prints a 16-bit value as binary with leading zeros
void printRegisters(uint8_t driver_id);     // Prints some of the registers of the selected driver
void Configure_BMI270_LowPower_AnyMotion(struct bmi2_dev *dev);
void EnterStandbyMode(void);
void ResetInactivityTimer(void);
void CheckWakeupSource(void);
void Wakeup_Reinit_Peripherals(void);
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
void CheckWakeupSource(void) {
  if (__HAL_PWR_GET_FLAG(PWR_FLAG_SB) != RESET) {
      __HAL_PWR_CLEAR_FLAG(PWR_FLAG_SB); // Clear Standby flag

      // Check individual wakeup flags
      if (__HAL_PWR_GET_FLAG(PWR_FLAG_WUF1) != RESET) { // PA0 - IMU
          __HAL_PWR_CLEAR_FLAG(PWR_FLAG_WUF1);
          printf("Woke up from Standby via IMU (WKUP1/PA0).\r\n");
          g_wakeup_source = WAKEUP_SOURCE_IMU;
          HAL_PWR_DisableWakeUpPin(PWR_WAKEUP_PIN1);
      }
      // Add checks for other WKUP pins if used for buttons, e.g. PWR_FLAG_WUF2 etc.
      // else if (__HAL_PWR_GET_FLAG(PWR_FLAG_WUFx) != RESET) { ... }
      else {
          printf("Woke up from Standby (source other than IMU on PA0 or unknown).\r\n");
          g_wakeup_source = WAKEUP_SOURCE_UNKNOWN; // Or RTC, etc.
      }
  } else {
      printf("Normal power-on or reset (not from Standby).\r\n");
  }
}

void Configure_BMI270_LowPower_AnyMotion(struct bmi2_dev *dev) {
  int8_t rslt;
  uint8_t sens_list[1];
  struct bmi2_sens_config sens_cfg;
  struct bmi2_int_pin_config int_pin_cfg;

  printf("Configuring BMI270 for Low Power Any Motion...\r\n");

  // 1. Disable all sensors first (good practice before reconfiguring)
  uint8_t all_sensors_off[] = { BMI2_ACCEL, BMI2_GYRO, BMI2_AUX }; // Add BMI2_TEMP if ever used
  rslt = bmi270_sensor_disable(all_sensors_off, sizeof(all_sensors_off)/sizeof(all_sensors_off[0]), dev);
  if (rslt != BMI2_OK) {
      printf("BMI270 Disable All Sensors failed. Error: %d\r\n", rslt);
      Error_Handler();
  }
   printf("All sensors disabled.\r\n");

  // 2. Enable Accelerometer only
  sens_list[0] = BMI2_ACCEL;
  rslt = bmi270_sensor_enable(sens_list, 1, dev);
  if (rslt != BMI2_OK) {
      printf("BMI270 Accel Enable failed. Error: %d\r\n", rslt);
      Error_Handler();
  }
  printf("Accelerometer enabled.\r\n");

  // 3. Configure Accelerometer for low power
  //    Datasheet page 26, Table 6: Low power mode -> ACC_CONF.acc_filter_perf = 0
  //    Datasheet page 20, Flowchart: Recommends ACC_CONF = 0x17 for 50Hz, osr2_avg2, low power filter.
  //    ACC_CONF (0x40):
  //      [7] acc_filter_perf: 0 for low power
  //      [6:4] acc_bwp: 001b (OSR2_AVG2 for low power based on datasheet filter table for acc_filter_perf=0)
  //      [3:0] acc_odr: 0111b (50Hz - minimum for features if acc_filter_perf=0, page 41)
  //      Result: 0_001_0111 = 0x17
  sens_cfg.type = BMI2_ACCEL;
  rslt = bmi2_get_sensor_config(&sens_cfg, 1, dev); // Get current to modify
  if (rslt != BMI2_OK) {
      printf("BMI270 Get Accel Config failed. Error: %d\r\n", rslt);
      Error_Handler();
  }
  sens_cfg.cfg.acc.odr = BMI2_ACC_ODR_50HZ;        // 50Hz, as features might need this ODR minimum
  sens_cfg.cfg.acc.bwp = BMI2_ACC_OSR2_AVG2;       // Low power bandwidth (osr2_avg2)
  sens_cfg.cfg.acc.filter_perf = BMI2_POWER_OPT_MODE; // Low power filter performance (acc_filter_perf = 0)
  // sens_cfg.cfg.acc.range = BMI2_ACC_RANGE_2G; // Already set or keep default
  rslt = bmi2_set_sensor_config(&sens_cfg, 1, dev);
  if (rslt != BMI2_OK) {
      printf("BMI270 Accel Low Power Config failed. Error: %d\r\n", rslt);
      Error_Handler();
  }
  printf("Accelerometer configured for low power (ODR: 50Hz, BWP: OSR2_AVG2, Filter: Power Optimized).\r\n");

  // 4. Enable Advanced Power Saving (after sensor config)
  //    PWR_CONF (0x7C): bit 1 adv_power_save = 1
  rslt = bmi2_set_adv_power_save(BMI2_ENABLE, dev);
  if (rslt != BMI2_OK) {
      printf("BMI270 Enable Advanced Power Save failed. Error: %d\r\n", rslt);
      Error_Handler();
  }
  printf("Advanced Power Saving enabled.\r\n");

  // 5. Configure Any-Motion feature
  //    ANYMO_1 (Page 1, 0x0C-0x0D in FEATURES): duration, select_x/y/z
  //    ANYMO_2 (Page 1, 0x0E-0x0F in FEATURES): threshold, enable
  struct bmi2_sens_config anymotion_cfg;
  anymotion_cfg.type = BMI2_ANY_MOTION;
  rslt = bmi270_get_sensor_config(&anymotion_cfg, 1, dev); // Get defaults
   if (rslt != BMI2_OK) {
      printf("BMI270 Get AnyMotion Config failed. Error: %d\r\n", rslt);
      // Don't Error_Handler() here, could be feature not active yet. We will set it.
  }

  anymotion_cfg.cfg.any_motion.duration = 2;    // 2 samples * 20ms/sample (at 50Hz) = 40ms
  anymotion_cfg.cfg.any_motion.threshold = 20;  // Threshold: 20 * 0.061mg/LSB (for 2g range) ~ 1.22mg.
                                                // For 2g range, sensitivity is 16384 LSB/g.
                                                // Threshold (g) = threshold_lsb / 16384.
                                                // Threshold (mg) = (threshold_lsb * 1000) / 16384.
                                                // A value of 20 means 20 * 1000 / 16384 ~= 1.22 mg. This is very sensitive.
                                                // Datasheet page 43 typical threshold is 0xAA for anymotion (83mg). Let's try that.
  anymotion_cfg.cfg.any_motion.threshold = 0xAA; // Let's use a moderate value like 32 decimal for testing (~2mg)
  anymotion_cfg.cfg.any_motion.select_x = BMI2_ENABLE;
  anymotion_cfg.cfg.any_motion.select_y = BMI2_ENABLE;
  anymotion_cfg.cfg.any_motion.select_z = BMI2_ENABLE;
  // The .enable field within any_motion struct is for axis selection, not the feature itself.
  // Feature is enabled by bmi270_sensor_enable for BMI2_ANY_MOTION type.

  rslt = bmi270_set_sensor_config(&anymotion_cfg, 1, dev);
  if (rslt != BMI2_OK) {
      printf("BMI270 Set AnyMotion Config failed. Error: %d\r\n", rslt);
      Error_Handler();
  }
  printf("Any Motion configured (Duration: %d, Threshold: 0x%X).\r\n",
         anymotion_cfg.cfg.any_motion.duration, anymotion_cfg.cfg.any_motion.threshold);


  // 6. Enable Any-Motion feature
  sens_list[0] = BMI2_ANY_MOTION;
  rslt = bmi270_sensor_enable(sens_list, 1, dev);
  if (rslt != BMI2_OK) {
      printf("BMI270 AnyMotion Sensor Enable failed. Error: %d\r\n", rslt);
      Error_Handler();
  }
  printf("Any Motion feature enabled.\r\n");

  // 7. Configure BMI270 Interrupt Pin (e.g., INT1)
  //    INT1_IO_CTRL (0x53), INT_LATCH (0x55)
  int_pin_cfg.pin_type = BMI2_INT1; // Or BMI2_INT2, ensure physical connection matches
  int_pin_cfg.int_latch = BMI2_INT_NON_LATCH; // Non-latched for edge trigger
  int_pin_cfg.pin_cfg[0].lvl = BMI2_INT_ACTIVE_HIGH; // Active high for STM32 rising edge EXTI
  int_pin_cfg.pin_cfg[0].od = BMI2_INT_PUSH_PULL;
  int_pin_cfg.pin_cfg[0].output_en = BMI2_INT_OUTPUT_ENABLE;
  int_pin_cfg.pin_cfg[0].input_en = BMI2_INT_INPUT_DISABLE; // INT1 as output
  // If using BMI2_INT2, configure pin_cfg[1]
  rslt = bmi2_set_int_pin_config(&int_pin_cfg, dev);
  if (rslt != BMI2_OK) {
      printf("BMI270 Set INT Pin Config failed. Error: %d\r\n", rslt);
      Error_Handler();
  }
  printf("BMI270 INT1 configured as Active High, Push-Pull output.\r\n");

  // 8. Map Any-Motion interrupt to the configured INT pin
  rslt = bmi2_map_feat_int(BMI2_ANY_MOTION, BMI2_INT1, dev); // Map to INT1
  if (rslt != BMI2_OK) {
      printf("BMI270 Map AnyMotion to INT1 failed. Error: %d\r\n", rslt);
      Error_Handler();
  }
  printf("Any Motion interrupt mapped to INT1.\r\n");
  printf("BMI270 Low Power Any Motion Setup Complete.\r\n");
}

void EnterStop2Mode(void) {
  printf("Preparing to enter Stop2 Mode...\r\n");
  WS2812_SetColor(0,0,0,0); // Turn off LED

  HAL_GPIO_WritePin(nSLEEP_FRONT_GPIO_Port, nSLEEP_FRONT_Pin, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(nSLEEP_REAR_GPIO_Port, nSLEEP_REAR_Pin, GPIO_PIN_RESET);
  printf("nSLEEP pins set LOW.\r\n");
  HAL_Delay(100); // UART flush

  // Stop peripherals and timers to prevent them from waking the MCU
  HAL_TIM_Base_Stop_IT(&htim2);
  HAL_TIM_Base_Stop_IT(&htim16);
  HAL_ADC_Stop(&hadc1); // Ensure ADC is stopped

  // Clear all wakeup flags to prevent immediate re-wakeup
  __HAL_GPIO_EXTI_CLEAR_FLAG(IMU_INT1_Pin);
  __HAL_PWR_CLEAR_FLAG(PWR_FLAG_WU);
  __HAL_GPIO_EXTI_CLEAR_FLAG(IMU_INT1_Pin | BUTTON1_Pin | BUTTON2_Pin | BUTTON3_Pin | BUTTON4_Pin | BUTTON5_Pin);
  __HAL_PWR_CLEAR_FLAG(PWR_FLAG_WUF1 | PWR_FLAG_WUF2 | PWR_FLAG_WUF3 | PWR_FLAG_WUF4 | PWR_FLAG_WUF5);
  // __HAL_PWR_CLEAR_FLAG(PWR_FLAG_WUF1 | PWR_FLAG_WUF2 | PWR_FLAG_WUF3 | PWR_FLAG_WUF4 | PWR_FLAG_WUF5);

  // Enter Stop2 mode
  HAL_SuspendTick(); // Suspend SysTick to prevent wakeup from it
  HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
}

void EnterStandbyMode(void) {
  printf("Preparing to enter Standby Mode...\r\n");
  WS2812_SetColor(0,0,0,0);

  // Set nSLEEP pins of external devices low if needed
  HAL_GPIO_WritePin(nSLEEP_FRONT_GPIO_Port, nSLEEP_FRONT_Pin, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(nSLEEP_REAR_GPIO_Port, nSLEEP_REAR_Pin, GPIO_PIN_RESET);
  printf("nSLEEP pins set LOW.\r\n");
  HAL_Delay(100); // UART flush

  // 1. Enable PWR peripheral clock
  //  __HAL_RCC_PWR_CLK_ENABLE();

  // 4. Enable the desired WakeUp Pin (PA0 = WKUP1, rising edge for active high IMU signal)
  HAL_PWR_EnableWakeUpPin(PWR_WAKEUP_PIN1_HIGH);

  // 3. Disable unused WakeUp Pins
  HAL_PWR_DisableWakeUpPin(PWR_WAKEUP_PIN2);
  HAL_PWR_DisableWakeUpPin(PWR_WAKEUP_PIN3);
  HAL_PWR_DisableWakeUpPin(PWR_WAKEUP_PIN4);
  HAL_PWR_DisableWakeUpPin(PWR_WAKEUP_PIN5);

  // 2. Clear ALL Wakeup Flags (Standby and individual WUFx)
  //    This prevents immediate wakeup if a flag was already set.
  __HAL_PWR_CLEAR_FLAG(PWR_FLAG_WU);
  __HAL_PWR_CLEAR_FLAG(PWR_FLAG_WUF1 | PWR_FLAG_WUF2 | PWR_FLAG_WUF3 | PWR_FLAG_WUF4 | PWR_FLAG_WUF5); // Clear all at once

  // 5. Enter Standby mode
  HAL_PWR_EnterSTANDBYMode();
  // MCU should reset on wakeup from here
}

void ResetInactivityTimer(void) {
  // printf("Inactivity timer reset.\r\n");
  inactivity_timer_elapsed_flag = false;
  __HAL_TIM_SET_COUNTER(&htim16, 0); // Reset counter for TIM6
  HAL_TIM_Base_Start_IT(&htim16);    // Restart TIM6
}

void Wakeup_Reinit_Peripherals(void)
{
    printf("Re-initializing peripherals after wakeup...\r\n");

    // De-initialize all used peripherals to reset their HAL state handles.
    HAL_TIM_Base_DeInit(&htim2);
    HAL_TIM_Base_DeInit(&htim16);
    HAL_ADC_DeInit(&hadc1);
    HAL_I2C_DeInit(&hi2c1);
    HAL_I2C_DeInit(&hi2c3);
//    HAL_SPI_DeInit(&spi2);
    HAL_UART_DeInit(&huart1);

    // Re-initialize all peripherals as if from a cold boot.

    MX_GPIO_Init(); // Good practice to re-init GPIOs too
    MX_DMA_Init();
    MX_ADC1_Init();
    MX_I2C1_Init();
    MX_I2C3_Init();
    MX_SPI2_Init();
    MX_TIM2_Init();
    MX_TIM16_Init();
    MX_USART1_UART_Init();

    // Restart any timers that should be running
    if (HAL_TIM_Base_Start_IT(&htim2) != HAL_OK) { Error_Handler(); }

    // Re-select the I2C MUX channel since the I2C peripheral was reset.
    if (i2c_mux_select(&i2c_multiplexer, i2c_channel_to_use) != 0) {
        printf("Failed to re-select MUX channel %d after wakeup.\n", i2c_channel_to_use);
    } else {
        printf("I2C MUX channel %d re-selected successfully.\n", i2c_channel_to_use);
    }
}
/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */
  CheckWakeupSource();
  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* Configure the peripherals common clocks */
  PeriphCommonClock_Config();

  /* IPCC initialisation */
  MX_IPCC_Init();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_DMA_Init();
  MX_ADC1_Init();
  MX_I2C1_Init();
  MX_I2C3_Init();
  MX_RTC_Init();
  MX_TIM2_Init();
  MX_SPI2_Init();
  MX_USART1_UART_Init();
  MX_TIM16_Init();
  /* USER CODE BEGIN 2 */
  printf(" System Initialized. Wakeup source: %d (0=Unk, 1=IMU)\r\n", g_wakeup_source);
  // Default GPIO states
  // HAL_GPIO_WritePin(nSLEEP_FRONT_GPIO_Port, nSLEEP_FRONT_Pin, GPIO_PIN_RESET);
  // HAL_GPIO_WritePin(nSLEEP_REAR_GPIO_Port, nSLEEP_REAR_Pin, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(BAT_SENSE_EN_GPIO_Port, BAT_SENSE_EN_Pin, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(MUX_RESET_GPIO_Port, MUX_RESET_Pin, GPIO_PIN_SET);

  // Start the timer in interrupt mode
  // Example: if you want to measure every 5 seconds, and your timer is TIM2
  // Configure TIM2 in CubeMX for a 5-second period (e.g., Prescaler & Period values)
  // and enable its update interrupt.
  if (HAL_TIM_Base_Start_IT(&htim2) != HAL_OK) { Error_Handler();}

  printf("Initializing PCA9546A multiplexer... ");
  // Initialize the I2C multiplexer structure
  i2c_multiplexer.hi2c = &hi2c1; // Assign the I2C peripheral handle
  i2c_multiplexer.rst_port = MUX_RESET_GPIO_Port;  // From main.h
  i2c_multiplexer.rst_pin = MUX_RESET_Pin;         // From main.h
  i2c_multiplexer.addr_offset = 0;

  // select the desired chanel based on the switch 1 position
  if (HAL_GPIO_ReadPin(SWITCH1_GPIO_Port, SWITCH1_Pin) == GPIO_PIN_SET) {
    i2c_channel_to_use = 0; // Channel 1
    HAL_GPIO_WritePin(nSLEEP_FRONT_GPIO_Port, nSLEEP_FRONT_Pin, GPIO_PIN_SET);
    HAL_GPIO_WritePin(nSLEEP_REAR_GPIO_Port, nSLEEP_REAR_Pin, GPIO_PIN_RESET);
  } else {
    i2c_channel_to_use = 1; // Channel 0
    HAL_GPIO_WritePin(nSLEEP_FRONT_GPIO_Port, nSLEEP_FRONT_Pin, GPIO_PIN_RESET);
    HAL_GPIO_WritePin(nSLEEP_REAR_GPIO_Port, nSLEEP_REAR_Pin, GPIO_PIN_SET);
  }
  if (i2c_mux_select(&i2c_multiplexer, i2c_channel_to_use) == 0) {
      printf("PCA9546A Initialized Successfully! Channel %d selected.\n", i2c_channel_to_use);
  } else {
      printf("Failed to select channel %d on I2C multiplexer.\n", i2c_channel_to_use);
  }

  // I2C1 scanning
  I2C_Scan(&hi2c1);
  // I2C3 scanning
  I2C_Scan(&hi2c3);

  printf("Initializing DRV8214 drivers...\n");
  // Pass the HAL I2C handle to the I2C platform layer
  drv8214_i2c_set_handle(&hi2c1); // &hi2c1 is defined in Core/Src/i2c.c and declared in Core/Inc/i2c.h
  for (int i = 0; i < NUM_DRIVERS; i++) {  // Initialize each driver
    driver_configs[i] = DRV8214_Config();
    if (drivers[i].init(driver_configs[i]) == DRV8214_OK) {
      drivers[i].resetFaultFlags();
      printf("DRV8214 driver %d initialized successfully!\n", i);
    } else {
      printf("Failed to initialize DRV8214 driver %d.\n", i);
      Error_Handler();
    }
  }

  printf("Initializing BMI270 IMU... ");
  bmi2_set_i2c_handle(&hi2c3);
  // Configure the bmi2_dev structure
  bmi270_sensor.intf_ptr = &hi2c3; // Pass a pointer to the I2C HAL handle
  bmi270_sensor.intf = BMI2_I2C_INTF;
  bmi270_sensor.read = bmi2_i2c_read;
  bmi270_sensor.write = bmi2_i2c_write;
  bmi270_sensor.delay_us = bmi2_delay_us;
  bmi270_sensor.read_write_len = 32;    // Max burst read/write length (check BMI270 datasheet, 32 or 64 for features is common)
                                        // For config file loading, this might need to be larger if the API doesn't chunk it.
                                        // The bmi270_config_file is 8KB, the API chunks this. 32 should be fine for most operations.
  bmi270_sensor.config_file_ptr = NULL; // bmi270_init will assign the internal one
  int8_t rslt_bmi = bmi270_init(&bmi270_sensor);
  if (rslt_bmi == BMI2_OK) {
      printf("BMI270 initialized successfully! Chip ID: 0x%X\r\n", bmi270_sensor.chip_id);
  } else {
      printf("BMI270 initialization failed. Error code: %d\r\n", rslt_bmi);
      Error_Handler();
  }

  // --- BMI270 LOW POWER AND ANY MOTION SETUP ---
  if (rslt_bmi == BMI2_OK) {
    Configure_BMI270_LowPower_AnyMotion(&bmi270_sensor);
  }
  // --- END BMI270 SETUP ---

  if (g_wakeup_source == WAKEUP_SOURCE_UNKNOWN) { // Only blink on cold boot
      WS2812_SetColor(255, 0, 0, 100); HAL_Delay(330);
      WS2812_SetColor(0, 255, 0, 100); HAL_Delay(330);
      WS2812_SetColor(0, 0, 255, 100); HAL_Delay(330);
  } else if (g_wakeup_source == WAKEUP_SOURCE_IMU) {
      WS2812_SetColor(255, 255, 255, 100); // White for IMU wakeup
      HAL_Delay(1000);
  }
  WS2812_SetColor(0, 0, 0, 0);

  ResetInactivityTimer(); // Start the 30-second inactivity timer
  printf("Main loop started. Inactivity timer running for %lu ms.\r\n", INACTIVITY_TIMEOUT_MS);

  // // --- Example: Enable Accelerometer and Gyroscope ---
  // if (rslt_bmi == BMI2_OK) {
  //   uint8_t sens_list[] = { BMI2_ACCEL, BMI2_GYRO };
  //   rslt_bmi = bmi270_sensor_enable(sens_list, 2, &bmi270_sensor);
  //   if (rslt_bmi != BMI2_OK) {
  //       printf("BMI270 Sensor Enable failed. Error: %d\r\n", rslt_bmi);
  //   } else {
  //       printf("BMI270 Accel & Gyro enabled.\r\n");
  //   }

  //   // Configure Accelerometer (example: 2g range, 100Hz ODR, Normal Mode)
  //   struct bmi2_sens_config sens_cfg;
  //   sens_cfg.type = BMI2_ACCEL;
  //   sens_cfg.cfg.acc.range = BMI2_ACC_RANGE_2G;
  //   sens_cfg.cfg.acc.odr = BMI2_ACC_ODR_100HZ;
  //   sens_cfg.cfg.acc.bwp = BMI2_ACC_NORMAL_AVG4; // Normal bandwidth parameter
  //   sens_cfg.cfg.acc.filter_perf = BMI2_PERF_OPT_MODE; // Filter performance mode
  //   rslt_bmi = bmi2_set_sensor_config(&sens_cfg, 1, &bmi270_sensor);
  //   if (rslt_bmi != BMI2_OK) {
  //       printf("BMI270 Accel Config failed. Error: %d\r\n", rslt_bmi);
  //   } else {
  //       printf("BMI270 Accel configured.\r\n");
  //   }
    
  //   // Configure Gyroscope (example: 2000dps range, 100Hz ODR, Normal Mode)
  //   sens_cfg.type = BMI2_GYRO;
  //   sens_cfg.cfg.gyr.range = BMI2_GYR_RANGE_2000;
  //   sens_cfg.cfg.gyr.odr = BMI2_GYR_ODR_100HZ;
  //   sens_cfg.cfg.gyr.bwp = BMI2_GYR_NORMAL_MODE; // Normal bandwidth parameter
  //   sens_cfg.cfg.gyr.filter_perf = BMI2_PERF_OPT_MODE; // Filter performance mode
  //   sens_cfg.cfg.gyr.noise_perf = BMI2_POWER_OPT_MODE; // Noise performance mode
  //   rslt_bmi = bmi2_set_sensor_config(&sens_cfg, 1, &bmi270_sensor);
  //   if (rslt_bmi != BMI2_OK) {
  //       printf("BMI270 Gyro Config Failed. Error: %d\r\n", rslt_bmi);
  //   } else {
  //       printf("BMI270 Gyro configured.\r\n");
  //   }
  // }

  // Blink the LED to indicate startup finished
  WS2812_SetColor(255, 0, 0, 100);
  HAL_Delay(330);
  WS2812_SetColor(0, 255, 0, 100);
  HAL_Delay(330);
  WS2812_SetColor(0, 0, 255, 100);
  HAL_Delay(330);
  WS2812_SetColor(0, 0, 0, 100); // Turn off the LED

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */

  while (1)
  { 
    // Check for inactivity timer timeout
	  if (inactivity_timer_elapsed_flag) {
      inactivity_timer_elapsed_flag = false; // Clear flag

      // --- Prepare and Enter Stop 2 Mode ---
      EnterStop2Mode();

      // 1. Resume the HAL Tick. Essential for HAL_Delay and timeouts.
      HAL_ResumeTick();

      // 2. Restore the high-speed system clock (PLL). CRITICAL!
      SystemClock_Config();

      // 3. Re-initialize peripherals that were affected by the clock change or Stop mode.
      Wakeup_Reinit_Peripherals();

      // 4. Now that the system is fully functional again, handle the logic.
      printf("Woke up from Stop 2. System is active.\r\n");

      // Optional: You can use the flag from the ISR to confirm the source
      if (woke_up_from_stop_mode) {
            woke_up_from_stop_mode = false; // Clear the flag for the next cycle
            printf("Wakeup source: IMU interrupt.\r\n");
            WS2812_SetColor(255, 100, 0, 100); // Orange to indicate IMU wakeup
            HAL_Delay(500);
            WS2812_SetColor(0, 0, 0, 0);
      }
      // 5. Restart the inactivity timer for the next cycle.
      ResetInactivityTimer();
    }

    if (woke_up_from_stop_mode) {
      printf("Motion detected!\r\n");
      woke_up_from_stop_mode = false; // Clear the flag for the next cycle
      WS2812_SetColor(255, 100, 0, 100); // Orange to indicate IMU wakeup
      HAL_Delay(200);
      WS2812_SetColor(0, 0, 0, 0);
    }

    if (HAL_GPIO_ReadPin(SWITCH1_GPIO_Port, SWITCH1_Pin) == GPIO_PIN_SET && i2c_channel_to_use == 0) {
      i2c_channel_to_use = 1;
      HAL_GPIO_WritePin(nSLEEP_FRONT_GPIO_Port, nSLEEP_FRONT_Pin, GPIO_PIN_RESET);
      HAL_GPIO_WritePin(nSLEEP_REAR_GPIO_Port, nSLEEP_REAR_Pin, GPIO_PIN_SET);
      if (i2c_mux_select(&i2c_multiplexer, i2c_channel_to_use) == 0) {
        printf("Channel %d selected successfully!\n", i2c_channel_to_use);
      } else {
          printf("Failed to select channel %d on I2C multiplexer.\n", i2c_channel_to_use);
      }
      HAL_Delay(10);
      driver_configs[i2c_channel_to_use] = DRV8214_Config();
      	 drivers[i2c_channel_to_use].init(driver_configs[i2c_channel_to_use]);
      	 drivers[i2c_channel_to_use].resetFaultFlags();
    } else if (HAL_GPIO_ReadPin(SWITCH1_GPIO_Port, SWITCH1_Pin) == GPIO_PIN_RESET && i2c_channel_to_use == 1) {
        i2c_channel_to_use = 0;
        HAL_GPIO_WritePin(nSLEEP_FRONT_GPIO_Port, nSLEEP_FRONT_Pin, GPIO_PIN_SET);
        HAL_GPIO_WritePin(nSLEEP_REAR_GPIO_Port, nSLEEP_REAR_Pin, GPIO_PIN_RESET);
        if (i2c_mux_select(&i2c_multiplexer, i2c_channel_to_use) == 0) {
          printf("Channel %d selected successfully!\n", i2c_channel_to_use);
        } else {
            printf("Failed to select channel %d on I2C multiplexer.\n", i2c_channel_to_use);
        }
        HAL_Delay(10);
        driver_configs[i2c_channel_to_use] = DRV8214_Config();
      drivers[i2c_channel_to_use].init(driver_configs[i2c_channel_to_use]);
      drivers[i2c_channel_to_use].resetFaultFlags();
    }

    if (wakeup_event) {
      // Process the wakeup event (button press)
      printf("Button press detected! ID: %d\r\n", button_ID);
      wakeup_event = false; // Reset flag AFTER processing it
      // display LED color based on button press
      switch (button_ID) {
        case 1:
          WS2812_SetColor(255, 0, 0, 100); // Red
          // Move the motor forward
          drivers[i2c_channel_to_use].turnXRipples(ripple_target, stops_after_ripples, true, speed, voltage, current);
          //drivers[i2c_channel_to_use].turnForward(speed_low, voltage, current);
          break;
        case 2:
          WS2812_SetColor(0, 255, 0, 100); // Green
          // Move the motor backward

          drivers[1].turnReverse(speed_low, voltage, current);

          break;
        case 3:
          WS2812_SetColor(0, 0, 255, 100); // Blue
          printf("Clearing fault flags...\r\n");
          drivers[i2c_channel_to_use].resetRippleCounter();
          drivers[i2c_channel_to_use].resetFaultFlags();
          I2C_Scan(&hi2c1);
          HAL_Delay(1000); // Pause to see results
          break;
        case 4:
          WS2812_SetColor(255, 255, 0, 100); // Yellow
          printRegisters(i2c_channel_to_use);
          break;
        case 5:
          WS2812_SetColor(255, 0, 255, 100); // Magenta
          // Stop the motor
          drivers[i2c_channel_to_use].brakeMotor();
          break;
        default:
          WS2812_SetColor(0, 0, 0, 0); // Off
          break;
      }
      HAL_Delay(1000);
      WS2812_SetColor(0, 0, 0, 0); // Turn off the LED
    }

    if (rslt_bmi == BMI2_OK) { // Only if initialization and config were successful
      struct bmi2_sens_data sensor_values; // Use the union directly as per bmi2_get_sensor_data signature
      int8_t rslt_data;

      // The bmi2_get_sensor_data function will attempt to read data for
      // all sensors that are currently enabled (ACC, GYR, AUX) and sensortime.
      // It populates the fields within the 'sensor_values' union accordingly.
      rslt_data = bmi2_get_sensor_data(&sensor_values, &bmi270_sensor); // Pass the address of the union

      if (rslt_data == BMI2_OK) {
          // Check which sensors were enabled to print their data meaningfully
          // You can check dev->sens_en_stat or the PWR_CTRL register if needed,
          // or just assume accel and gyro are enabled based on prior setup.

          // Assuming Accelerometer was enabled
          printf("ACC: X=%d Y=%d Z=%d | ",
                 sensor_values.acc.x,
                 sensor_values.acc.y,
                 sensor_values.acc.z);

          // Assuming Gyroscope was enabled
          printf("GYR: X=%d Y=%d Z=%d",
                 sensor_values.gyr.x,
                 sensor_values.gyr.y,
                 sensor_values.gyr.z);

          // Print sensortime (if available and meaningful in your setup)
          // The bmi2_parse_sensor_data in bmi2.c shows how sens_time is populated in the struct.
          // If bmi2_get_sensor_data directly populates it:
          printf(" | ST: %lu\r\n", (unsigned long)sensor_values.sens_time);

      } else {
          printf("BMI270 Get Sensor Data Failed. Error: %d\r\n", rslt_data);
      }
      HAL_Delay(100); // Read data every 100ms
    }

    if (g_measure_battery_flag)
    { 
        g_measure_battery_flag = 0; // Reset the flag

        // 1. Enable BAT_SENSE circuitry
        HAL_GPIO_WritePin(BAT_SENSE_EN_GPIO_Port, BAT_SENSE_EN_Pin, GPIO_PIN_SET);

        // 2. Wait for voltage to settle (C504 charging)
        // Tau = R_eff * C = 2.31kOhm * 100nF = 0.231 ms. 5*Tau ~ 1.15 ms.
        // Let's use a slightly larger delay for safety margin.
        HAL_Delay(10); 

        // 3. Start ADC conversion
        if (HAL_ADC_Start(&hadc1) != HAL_OK)
        {
            printf("ADC Start Error\r\n");
            // Optionally turn off BAT_SENSE_EN here if error occurs early
            HAL_GPIO_WritePin(BAT_SENSE_EN_GPIO_Port, BAT_SENSE_EN_Pin, GPIO_PIN_RESET);
            // Handle error
        }
        else
        {
            // 4. Poll for ADC conversion complete (timeout e.g., 100ms)
            if (HAL_ADC_PollForConversion(&hadc1, 100) == HAL_OK)
            {
                // 5. Read ADC value
                uint32_t adc_raw_value = HAL_ADC_GetValue(&hadc1);

                // 6. Calculate voltage
                // V_sense = (ADC_raw / ADC_max_resolution) * V_ref
                float v_sense = ((float)adc_raw_value / ADC_RESOLUTION) * VREF_MCU;
                // VBAT = V_sense * (R502 + R503) / R503
                g_battery_voltage = v_sense * BATTERY_SENSE_DIVIDER_RATIO;

                // Convert battery voltage to millivolts (integer)
                uint32_t battery_millivolts = (uint32_t)(g_battery_voltage * 1000.0f);

                // Simple printf for debugging
                printf("ADC Raw: %lu, VBAT_mV: %lu\r\n",
                      adc_raw_value,
                      battery_millivolts);
            }
            else
            {
                printf("ADC Poll Timeout\r\n");
                // Handle timeout
            }
            // Stop ADC (important if not in continuous mode, good practice anyway)
            HAL_ADC_Stop(&hadc1);
        }

        // 7. Disable BAT_SENSE circuitry to save power
        HAL_GPIO_WritePin(BAT_SENSE_EN_GPIO_Port, BAT_SENSE_EN_Pin, GPIO_PIN_RESET);

        // Now g_battery_voltage holds the latest reading.
        // You can use it for low battery checks, display, etc.
    }
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSI1
                              |RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
  RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV1;
  RCC_OscInitStruct.PLL.PLLN = 30;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV3;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure the SYSCLKSource, HCLK, PCLK1 and PCLK2 clocks dividers
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK4|RCC_CLOCKTYPE_HCLK2
                              |RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.AHBCLK2Divider = RCC_SYSCLK_DIV2;
  RCC_ClkInitStruct.AHBCLK4Divider = RCC_SYSCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief Peripherals Common Clock Configuration
  * @retval None
  */
void PeriphCommonClock_Config(void)
{
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};

  /** Initializes the peripherals clock
  */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SMPS;
  PeriphClkInitStruct.SmpsClockSelection = RCC_SMPSCLKSOURCE_HSI;
  PeriphClkInitStruct.SmpsDivSelection = RCC_SMPSCLKDIV_RANGE1;

  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN Smps */

  /* USER CODE END Smps */
}

/* USER CODE BEGIN 4 */
/**
  * @brief  EXTI line detection callback.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
	if (GPIO_Pin == IMU_INT1_Pin)
  { 
	  woke_up_from_stop_mode = true;
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
  }
	else if (GPIO_Pin == BUTTON1_Pin) // Replace YOUR_BUTTON_PIN with the actual pin, e.g., GPIO_PIN_13
  {
	  wakeup_event = true; // Set flag for next loop iteration
	  __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
	  button_ID = 1;
    ResetInactivityTimer();
  } else if (GPIO_Pin == BUTTON2_Pin) {
	  wakeup_event = true; // Set flag for next loop iteration
	  __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
	  button_ID = 2;
    ResetInactivityTimer();
  }
  else if (GPIO_Pin == BUTTON3_Pin) {
	  wakeup_event = true; // Set flag for next loop iteration
	  __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
	  button_ID = 3;
    ResetInactivityTimer();
  }
  else if (GPIO_Pin == BUTTON4_Pin) {
	  wakeup_event = true; // Set flag for next loop iteration
	  __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
	  button_ID = 4;
    ResetInactivityTimer();
  }
  else if (GPIO_Pin == BUTTON5_Pin) {
    wakeup_event = true; // Set flag for next loop iteration
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
    button_ID = 5;
    ResetInactivityTimer();
  }
}

#ifdef __cplusplus
  extern "C" {
  #endif
#ifdef USE_SWD
  int _write(int file, char *ptr, int len)
  {
    (void)file;
    int DataIdx;

    for (DataIdx = 0; DataIdx < len; DataIdx++)
    {
      ITM_SendChar(*ptr++);
    }
    return len;
  }
#endif
#ifdef USE_UART
  int _write(int file, char *ptr, int len)
  {
    (void)file; // Unused parameter
    HAL_StatusTypeDef status;

    // Assuming huart1 is configured for USART1
    // Adjust if your handle is named differently or you use a different USART
    status = HAL_UART_Transmit(&huart1, (uint8_t *)ptr, len, HAL_MAX_DELAY);

    if (status == HAL_OK) {
        return len;
    } else {
        return -1;
    }
}
#endif
#ifdef __cplusplus
  }
#endif

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  // Check which Systick timer is generating the interrupt
  if (htim->Instance == TIM1) { // Or whatever your HAL_IncTick uses
    HAL_IncTick();
  }
  // Check if it's our battery measurement timer (e.g., TIM2)
  else if (htim->Instance == htim2.Instance) // Check against the specific timer instance
  {
    g_measure_battery_flag = 1;
  }
  else if (htim->Instance == TIM16) // Inactivity Timer (e.g. TIM16)
  {
    inactivity_timer_elapsed_flag = true;
    HAL_TIM_Base_Stop_IT(&htim16); // Stop timer, will be restarted on activity
    printf("Inactivity timer elapsed.\r\n");
  }
  // Add other timer callbacks if you have them
}

void I2C_Scan(I2C_HandleTypeDef *hi2c) {
  if (hi2c->Instance == I2C1) {
    printf("Scanning I2C Bus 1 (MUX Channel %d)...\r\n", i2c_channel_to_use);
  } else if (hi2c->Instance == I2C3) {
    printf("Scanning I2C Bus 3...\r\n");
  } else {
    printf("Scanning Unknown I2C Bus...\r\n");
  }

  HAL_StatusTypeDef res;
  uint8_t i = 0;
  for (i = 1; i < 128; i++) {
    res = HAL_I2C_IsDeviceReady(hi2c, (uint16_t)(i << 1), 2, 10); // 2 trials, 10ms timeout
    if (res == HAL_OK) {
      printf("I2C Device Found at Address: 0x%02X\r\n", i);
    }
  }
  if (hi2c->Instance == I2C1) {
    printf("I2C Bus 1 (MUX Channel %d) Scan Complete.\r\n", i2c_channel_to_use);
  } else if (hi2c->Instance == I2C3) {
    printf("I2C Bus 3 Scan Complete.\r\n");
  } else {
    printf("Unknown I2C Bus Scan Complete.\r\n");
  }
}

void printByteAsBinary(uint8_t value) {
  for (int i = 7; i >= 0; i--) {
    printf("%d", (value >> i) & 1); // Print 0 or 1
  }
}

void print2BytesAsBinary(uint16_t value) {
  for (int i = 15; i >= 0; i--) {
    printf("%d", (value >> i) & 1); // Print 0 or 1
  }
}


void printRegisters(uint8_t driver_id) {

  // variable to avoid float printing
  char buffer[50];
  printf("Speed of motor: ");
  printf("%d", drivers[driver_id].getMotorSpeedRPM());
  printf(" RPM or ");
  printf("%.2f", drivers[driver_id].getMotorSpeedRAD());
  printf(" rad/s | ");

  printf("Voltage: ");
  printf("%.2f", drivers[driver_id].getMotorVoltage());
  printf(" V | ");

  printf("Current: ");
  printf("%.2f", drivers[driver_id].getMotorCurrent());
  printf(" A | ");

  printf("Speed of shaft: ");
  printf("%d", drivers[driver_id].getMotorSpeedShaftRPM());
  printf(" RPM or ");
  printf("%.2f", drivers[driver_id].getMotorSpeedShaftRAD());
  printf(" rad/s | ");

  printf("Duty Cycle: ");
  printf("%hhu", drivers[driver_id].getDutyCycle()); // %hhu for uint8_t
  printf("%% | ");

  printf("Tinrush: ");
  printf("%hu", drivers[driver_id].getInrushDuration()); // %hu for uint16_t
  printf(" ms | "); // Added space and separator for consistency

  printf("RC_STATUS1 (SPEED): 0b");
  printByteAsBinary(drivers[driver_id].getMotorSpeedRegister());
  printf(" | ");

  printf("REG_STATUS1 (VOLTAGE): 0b");
  printByteAsBinary(drivers[driver_id].getMotorVoltageRegister());
  printf(" | ");

  printf("REG_STATUS2 (CURRENT): 0b");
  printByteAsBinary(drivers[driver_id].getMotorCurrentRegister());
  printf(" | ");

  printf("Ripple counter: ");
  printf("%hu", drivers[driver_id].getRippleCount()); // %hu for uint16_t
  printf(" | 0b");
  print2BytesAsBinary(drivers[driver_id].getRippleCount());
  printf(" | ");

  drivers[driver_id].printFaultStatus(); // Assuming this function prints its own content + newline if needed

  printf("CONFIG0: 0b");
  printByteAsBinary(drivers[driver_id].getCONFIG0());
  printf(" | ");

  printf("CONFIG3: 0b");
  printByteAsBinary(drivers[driver_id].getCONFIG3());
  printf(" | ");

  printf("CONFIG4: 0b");
  printByteAsBinary(drivers[driver_id].getCONFIG4());
  printf(" | ");

  printf("REG_CTRL0: 0b");
  printByteAsBinary(drivers[driver_id].getREG_CTRL0());
  printf(" | ");

  printf("REG_CTRL1 (TARGET SPEED): 0b");
  printByteAsBinary(drivers[driver_id].getREG_CTRL1());
  printf(" | ");

  printf("REG_CTRL2 (DUTY): 0b");
  printByteAsBinary(drivers[driver_id].getREG_CTRL2());
  printf(" | ");

  printf("RC_CTRL0: 0b");
  printByteAsBinary(drivers[driver_id].getRC_CTRL0());
  printf(" | ");

  printf("KMC: ");
  printf("%hhu", drivers[driver_id].getKMC()); // %hhu for uint8_t
  printf(" | Ripple Threshold Scaled: ");
  printf("%hu", drivers[driver_id].getRippleThresholdScaled()); // %hu for uint16_t
  printf(" | Ripples Threshold: ");
  printf("%hu", drivers[driver_id].getRippleThreshold()); // %hu for uint16_t
  printf(" or 0b");
  print2BytesAsBinary(drivers[driver_id].getRippleThreshold());
  printf(" | ");

  printf("RC_CTRL1: 0b");
  printByteAsBinary(drivers[driver_id].getRC_CTRL1());
  printf(" | ");

  printf("RC_CTRL2: 0b");
  printByteAsBinary(drivers[driver_id].getRC_CTRL2());
  printf(" | ");

  printf("RC_CTRL6: 0b");
  printByteAsBinary(drivers[driver_id].getRC_CTRL6());
  printf(" | ");

  printf("RC_CTRL7: 0b");
  printByteAsBinary(drivers[driver_id].getRC_CTRL7());
  printf(" | ");

  printf("RC_CTRL8: 0b");
  printByteAsBinary(drivers[driver_id].getRC_CTRL8());
  printf("\n"); // Final newline for the whole block
}
/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
    // red LED ON
    WS2812_SetColor(255, 0, 0, 100); // Red
    HAL_Delay(200); // Wait for 1 second
    WS2812_SetColor(0, 0, 0, 0); // Turn off the LED
    HAL_Delay(200); // Wait for 1 second
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
